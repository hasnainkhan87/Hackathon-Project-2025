[
    {
        "function_name": "HideObjectKeyframe",
        "description": "No description available.",
        "code": "def HideObjectKeyframe(obj,frame_number):\n    # Hide the object from the start of the scene until the desired frame number\n    # Keyframes from 0 to T-1 to ensure it remains hidden the entire time.\n    obj.hide_render = True\n    obj.keyframe_insert(data_path=\"hide_render\",frame=0)\n    obj.keyframe_insert(data_path=\"hide_render\",frame=frame_number-1)\n    # Display the object for frame T and save keyframe.\n    obj.hide_render = False\n    obj.keyframe_insert(data_path=\"hide_render\",frame=frame_number)\n    # Hide object again at frame T+1 and save keyframe.\n    obj.hide_render = True\n    obj.keyframe_insert(data_path=\"hide_render\",frame=frame_number+1)",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Animation.py"
    },
    {
        "function_name": "generate_rgb",
        "description": "No description available.",
        "code": "def generate_rgb(color):\n    if type(color) == str:\n        return hex_to_rgb(color)\n    elif type(color) == int or type(color) == float:\n        return wavelength_to_rgb(color)",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Colors.py"
    },
    {
        "function_name": "hex_to_rgb",
        "description": "No description available.",
        "code": "def hex_to_rgb(hex):\n    h = hex.lstrip('#')\n    (r,g,b) = tuple(int(h[i:i+2], 16) for i in (0, 2, 4))\n    return r/255, g/255, b/255",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Colors.py"
    },
    {
        "function_name": "wavelength_to_rgb",
        "description": "This converts a given wavelength of light to an \napproximate RGB color value. The wavelength must be given\nin nanometers in the range from 380 nm through 750 nm\n(789 THz through 400 THz).\nBased on code by Dan Bruton\nhttp://www.physics.sfasu.edu/astro/color/spectra.html",
        "code": "def wavelength_to_rgb(wavelength, gamma=0.8):\n    ### Shamelessly hijacked from \n    # https://gist.github.com/error454/65d7f392e1acd4a782fc\n\n    '''This converts a given wavelength of light to an \n    approximate RGB color value. The wavelength must be given\n    in nanometers in the range from 380 nm through 750 nm\n    (789 THz through 400 THz).\n    Based on code by Dan Bruton\n    http://www.physics.sfasu.edu/astro/color/spectra.html\n    '''\n\n    wavelength = float(wavelength)\n    if wavelength >= 380 and wavelength <= 440:\n        attenuation = 0.3 + 0.7 * (wavelength - 380) / (440 - 380)\n        R = ((-(wavelength - 440) / (440 - 380)) * attenuation) ** gamma\n        G = 0.0\n        B = (1.0 * attenuation) ** gamma\n    elif wavelength >= 440 and wavelength <= 490:\n        R = 0.0\n        G = ((wavelength - 440) / (490 - 440)) ** gamma\n        B = 1.0\n    elif wavelength >= 490 and wavelength <= 510:\n        R = 0.0\n        G = 1.0\n        B = (-(wavelength - 510) / (510 - 490)) ** gamma\n    elif wavelength >= 510 and wavelength <= 580:\n        R = ((wavelength - 510) / (580 - 510)) ** gamma\n        G = 1.0\n        B = 0.0\n    elif wavelength >= 580 and wavelength <= 645:\n        R = 1.0\n        G = (-(wavelength - 645) / (645 - 580)) ** gamma\n        B = 0.0\n    elif wavelength >= 645 and wavelength <= 750:\n        attenuation = 0.3 + 0.7 * (750 - wavelength) / (750 - 645)\n        R = (1.0 * attenuation) ** gamma\n        G = 0.0\n        B = 0.0\n    else:\n        R = 0.0\n        G = 0.0\n        B = 0.0\n    return R, G, B",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Colors.py"
    },
    {
        "function_name": "CreateMaterial",
        "description": "No description available.",
        "code": "def CreateMaterial(MatName=\"NewMaterial\",HexColor=\"#FFFFFF\",Transmission=0.0,IOR=1.45,Roughness=0.0,EmissionColor=\"#000000\",EmissionStrength=0,Transparency=1.0,Metallic=0.0):\n    # Creating Materials is such a process.  this function makes it a little easier to do.\n    # I'll likely update this in the future with the full array of material options, or \n    # alternatively create a way to just import existing materials from a library or something.\n    mat = bpy.data.materials.new(name=MatName)\n    mat.use_nodes=True\n    mat_r,mat_g,mat_b = generate_rgb(HexColor)\n    em_r,em_g,em_b = generate_rgb(EmissionColor)\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (mat_r,mat_g,mat_b, 1)\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[17].default_value = Transmission\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[16].default_value = IOR\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[9].default_value = Roughness\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[19].default_value = (em_r,em_g,em_b, 1)\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[20].default_value = EmissionStrength\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[21].default_value = Transparency\n    mat.node_tree.nodes[\"Principled BSDF\"].inputs[6].default_value = Metallic\n    return mat",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Materials.py"
    },
    {
        "function_name": "AddMaterialToObject",
        "description": "No description available.",
        "code": "def AddMaterialToObject(obj,mat):\n    if obj.data.materials:\n        # assign to 1st material slot\n        obj.data.materials[0] = mat\n    else:\n        # no slots\n        obj.data.materials.append(mat)",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Materials.py"
    },
    {
        "function_name": "InitialSetup",
        "description": "No description available.",
        "code": "def InitialSetup(outputdir=os.getenv(\"HOME\")):\n    ### Make Background transparent (good for overlays)\n    bpy.context.scene.render.film_transparent = True\n\n    ### Output Format and Filepath\n    bpy.context.scene.render.image_settings.file_format = 'FFMPEG'\n    bpy.context.scene.render.filepath = outputdir\n    print(\"Output File Location: \", bpy.context.scene.render.filepath)\n\n    ### Set Animation end frame to n_frames\n    frames_per_second  = 30 #framerate of animation\n    animation_duration = 10 ##integer in seconds\n    bpy.context.scene.frame_end = frames_per_second * animation_duration\n\n    ### Set Renderer to Cycles with GPU support\n    bpy.context.scene.render.engine = 'CYCLES'\n    bpy.context.scene.cycles.samples = 4096\n    bpy.context.scene.cycles.device = 'GPU'",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "LoadSTLwithMaterial",
        "description": "No description available.",
        "code": "def LoadSTLwithMaterial(STL_file,material):\n    name = STL_file.split(\"/\")[-1].replace(\".stl\",\"\")\n    bpy.ops.import_mesh.stl(filepath=STL_file)\n    curr_scene = bpy.context.scene\n    obj = curr_scene.objects[name]\n    AddMaterialToObject(obj,material)\n    return obj",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "SubdivideSurface",
        "description": "No description available.",
        "code": "def SubdivideSurface():\n    bpy.ops.object.modifier_add(type='SUBSURF')\n    bpy.context.object.modifiers[\"Subdivision\"].levels = 0\n    bpy.context.object.modifiers[\"Subdivision\"].render_levels = 2",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "CreateNewCollection",
        "description": "No description available.",
        "code": "def CreateNewCollection(collection_name,owner=None):\n    coll = bpy.data.collections.new(collection_name)\n    if owner == None:\n        bpy.context.scene.collection.children.link(coll)\n    else:\n        owner.children.link(coll)\n    return coll",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "Add_Center_Of_Collection",
        "description": "No description available.",
        "code": "def Add_Center_Of_Collection(collection):\n    [x,y,z] = [0,0,0]\n    i=0\n    for obj in collection.all_objects:\n        x+=obj.location[0]\n        y+=obj.location[1]\n        z+=obj.location[2]\n        i+=1\n    bpy.ops.object.empty_add(type='PLAIN_AXES', align='WORLD', location=(x/i, y/i, z/i), scale=(1, 1, 1))\n    plain_axes = bpy.context.active_object\n    plain_axes.name=\"GeometricCenterOfCollection\"\n    collection.objects.link(plain_axes)\n    bpy.data.collections[\"Collection\"].objects.unlink(plain_axes)\n    return plain_axes",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "JoinCollectionToOneMesh",
        "description": "No description available.",
        "code": "def JoinCollectionToOneMesh(collection):\n    for obj in collection.all_objects:\n        obj.select_set(True)\n    bpy.ops.object.join()\n    curr_obj = bpy.context.active_object\n    curr_obj.name = collection.name\n    return curr_obj",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "GeometricCenterofObject",
        "description": "No description available.",
        "code": "def GeometricCenterofObject(object):\n    x = np.median([x.co[0] for x in object.data.vertices])\n    y = np.median([x.co[1] for x in object.data.vertices])\n    z = np.median([x.co[2] for x in object.data.vertices])\n    return (x,y,z)",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "TrackCameraToObject",
        "description": "No description available.",
        "code": "def TrackCameraToObject(object):\n    camera = bpy.context.scene.objects[\"Camera\"]\n    ttc = camera.constraints.new(type='TRACK_TO')\n    ttc.target = object",
        "source_file": "../ChemBlender-main\\BlenderUtilities\\Blender_Utilities.py"
    },
    {
        "function_name": "AddAtom",
        "description": "No description available.",
        "code": "def AddAtom(element,x,y,z,index):\n    bpy.ops.mesh.primitive_uv_sphere_add(radius=1, enter_editmode=False, align='WORLD', location=(x, y, z), scale=(0.1, 0.1, 0.1))\n    atom = bpy.context.active_object\n    atom.name=f\"{element}_{index}\"\n    AddMaterialToObject(atom,bpy.data.materials[element])\n    return atom",
        "source_file": "../ChemBlender-main\\ChemistryUtilities\\Blender_Chemistry.py"
    },
    {
        "function_name": "cylinder_between",
        "description": "No description available.",
        "code": "def cylinder_between(start,end,r):\n    x1,y1,z1 = start\n    x2,y2,z2 = end\n    dx = x2 - x1\n    dy = y2 - y1\n    dz = z2 - z1    \n    dist = math.sqrt(dx**2 + dy**2 + dz**2)\n    bpy.ops.mesh.primitive_cylinder_add(\n      radius = r, \n      depth = dist,\n      location = (dx/2 + x1, dy/2 + y1, dz/2 + z1)   \n    ) \n    phi = math.atan2(dy, dx) \n    theta = math.acos(dz/dist) \n    bpy.context.object.rotation_euler[1] = theta \n    bpy.context.object.rotation_euler[2] = phi \n    cyl = bpy.context.active_object\n    return cyl",
        "source_file": "../ChemBlender-main\\ChemistryUtilities\\Blender_Chemistry.py"
    },
    {
        "function_name": "AddBond",
        "description": "No description available.",
        "code": "def AddBond(i_atom,i,j_atom,j):\n    ## create cylinder of radius 0.1 (same as scale of atoms above)\n    i_element = i_atom[0]\n    j_element = j_atom[0]\n    i_start = [ float(i_atom[1]) , float(i_atom[2]) , float(i_atom[3])]\n    j_start = [ float(j_atom[1]) , float(j_atom[2]) , float(j_atom[3])]\n    midpoint = [ 0.5*j_start[0] + 0.5*i_start[0] , 0.5*j_start[1] + 0.5*i_start[1] , 0.5*j_start[2] + 0.5*i_start[2] ]\n    # Make i_atom bond\n    i_bond = cylinder_between(i_start, midpoint, 0.1)\n    i_bond.name=f\"{i_element}_{i+1}_{j_element}_{j+1}_a\"\n    AddMaterialToObject(i_bond,bpy.data.materials[i_element])\n    # Make j_atom bond        \n    j_bond = cylinder_between(j_start, midpoint, 0.1)\n    j_bond.name=f\"{i_element}_{i+1}_{j_element}_{j+1}_b\"\n    AddMaterialToObject(j_bond,bpy.data.materials[j_element])\n    return [i_bond,j_bond]",
        "source_file": "../ChemBlender-main\\ChemistryUtilities\\Blender_Chemistry.py"
    }
]